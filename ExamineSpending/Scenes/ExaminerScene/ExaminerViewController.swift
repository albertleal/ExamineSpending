//
//  ExaminerViewController.swift
//  ExamineSpending
//
//  Copyright (c) 2018 Aleksi Sitomaniemi. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import YMTreeMap

protocol ExaminerDisplayLogic: class {
  func displayError(message: String)
  func displayBlocks(viewModel: Examiner.TxnFetch.ViewModel)
  func displayProgress(viewModel: Examiner.Progress.ViewModel)
  func displayRequestActive(_ requestActive: Bool)
}

class ExaminerViewController: UIViewController, ExaminerDisplayLogic {
  @IBOutlet weak var treemap: TreemapView!
  @IBOutlet weak var spinner: UIActivityIndicatorView!

  var interactor: ExaminerBusinessLogic?
  var router: (NSObjectProtocol & ExaminerRoutingLogic & ExaminerDataPassing)?

  private var zoomRects: [CGRect] = []
  private var sourceRect: CGRect = CGRect.zero
  private var progressAlert: UIAlertController?

  // MARK: Object lifecycle
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  deinit {
    log.debug("")
  }

  // MARK: Setup
  private func setup() {
    let viewController = self
    let interactor = ExaminerInteractor()
    let presenter = ExaminerPresenter()
    let router = ExaminerRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }

  // MARK: Routing
  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("to\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }

  // MARK: View lifecycle
  override func viewDidLoad() {
    log.verbose("")
    super.viewDidLoad()
    treemap.delegate = self
    interactor?.fetchAccounts()
    self.navigationItem.hidesBackButton = true
    showCalendarButton(true)
    navigationItem.leftBarButtonItem = UIBarButtonItem.init(title: nil, style: .plain, target: self, action: nil)
  }

  // MARK: View Logic
  func displayBlocks(viewModel: Examiner.TxnFetch.ViewModel) {
    log.verbose("")
    dismissProgressAlert(atOnce: false)

    if viewModel.blocks.count == 0 {
      self.performSegue(withIdentifier: "TransactionPager", sender: self)
      return
    }
    showBreadCrumbs(viewModel.pathlen)

    navigationItem.title = viewModel.title
    if sourceRect != CGRect.zero {
      let transitionView = TreemapView.init(frame: sourceRect)
      view.addSubview(transitionView)
      transitionView.updateValues(blocks: viewModel.blocks)
      transitionView.backgroundColor = UIColor.white
      transitionView.alpha = 0.5
      UIView.animate(withDuration: 0.3, animations: {
        transitionView.alpha = 1.0
        transitionView.frame = self.treemap.frame
      }, completion: { _ in
        self.treemap.updateValues(blocks: viewModel.blocks)
        transitionView.removeFromSuperview()
      })
    } else {
      treemap.updateValues(blocks: viewModel.blocks)
    }
  }

  func displayProgress(viewModel: Examiner.Progress.ViewModel) {
    log.verbose("")
    if progressAlert == nil {
      progressAlert = UIAlertController.init(title: "Fetching", message: "...", preferredStyle: .alert)
      present(progressAlert!, animated: false)
    }
    progressAlert?.message = viewModel.progressInfo
  }

  func displayError(message: String) {
    log.verbose("")
    dismissProgressAlert(atOnce: true)
    let errorDialog = UIAlertController.init(title: "Error", message: message, preferredStyle: .alert)

    errorDialog.addAction(UIAlertAction.init(title: "OK", style: .cancel, handler: { _ in
      //If are showing error with no titles (case OP, no network connectivity), logout now.
      if self.treemap.titles.count == 0 {
        self.logout(UIBarButtonItem())
      }
    }))
    present(errorDialog, animated: true)
  }

  func displayRequestActive(_ requestActive: Bool) {
    log.verbose("")
    if requestActive {
      spinner.startAnimating()
    } else {
      spinner.stopAnimating()
    }
  }

  private func dismissProgressAlert(atOnce: Bool) {
    log.verbose("")
    if atOnce {
      self.doDismissProgressAlert(animated: false)
    }

    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.5) {
      self.doDismissProgressAlert(animated: true)
    }
  }

  private func doDismissProgressAlert(animated: Bool) {
    self.progressAlert?.dismiss(animated: animated, completion: {
      self.progressAlert = nil
    })
  }

  private func showCalendarButton(_ show: Bool) {
    if show {
      navigationItem.rightBarButtonItem = UIBarButtonItem.init(image: UIImage.init(named: "CalendarIcon"),
                                                               style: .plain,
                                                               target: self,
                                                               action: #selector(chooseDateRange(_:)))
    } else {
      navigationItem.rightBarButtonItem = nil
    }
  }

  private func showBreadCrumbs(_ count: Int) {
    var title = "◀"
    var sel = #selector(logout(_:))
    if count > 1 {
      for _ in 2...count {
        title += "■"
      }
      sel = #selector(backstep(_:))
    }
    navigationItem.leftBarButtonItem?.action = sel
    navigationItem.leftBarButtonItem?.title = title
  }

  @objc func chooseDateRange(_ sender: UIBarButtonItem) {
    performSegue(withIdentifier: "DateSelection", sender: self)
  }

  @objc func logout(_ sender: UIBarButtonItem) {
    navigationController?.popViewController(animated: true)
  }

  @objc func backstep(_ sender: UIBarButtonItem) {
    didPinchOut(view: self.treemap)
  }
}

extension ExaminerViewController: TreemapDelegate {
  func didTapRectangle(view: TreemapView, rectIndex: Int) {
    log.debug("Tappend rectangle index \(rectIndex)")
    var targetRect = view.treeMapRects[rectIndex]
    targetRect.origin.y += UIApplication.shared.statusBarFrame.height + (navigationController?.navigationBar.frame.size.height ?? 0)
    zoomRects.append(targetRect)
    sourceRect = zoomRects.last!
    interactor?.expand(request: Examiner.Expand.Request(groupIndex: rectIndex))
  }

  func didPinchOut(view: TreemapView) {
    log.verbose("")
    guard zoomRects.count > 0 else { return }
    sourceRect = zoomRects.removeLast()

    //Calculate the pinch-out frame, i.e. how to map the current full screen
    //display on to the previous layer
    let expW = view.frame.width * view.frame.width / sourceRect.width
    let expH = view.frame.height * view.frame.height / sourceRect.height
    let expX = -sourceRect.origin.x * expW / view.frame.width
    let expY = -sourceRect.origin.y * expH / view.frame.height
    sourceRect = CGRect.init(x: expX, y: expY, width: expW, height: expH)
    interactor?.collapse(request: Examiner.Collapse.Request())
  }
}
