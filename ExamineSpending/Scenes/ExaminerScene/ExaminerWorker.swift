//
//  ExaminerWorker.swift
//  ExamineSpending
//
//  Copyright (c) 2018 Aleksi Sitomaniemi. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ExaminerWorkerDelegate: class {
  func transactionsReceived(worker: ExaminerWorker, fetchComplete: Bool) -> Bool
  func transactionsFetchFailed(worker: ExaminerWorker, error: ESError)
}

class ExaminerWorker {
  weak var delegate: ExaminerWorkerDelegate?

  var fetchedTransactions: [ESTransaction] = []
  var accountId: String = ""

  private var continuationKey: String?
  private var dateRange: DateRange = DateRange()

  deinit {
    log.debug("")
  }

  func resetTransactions() {
    log.verbose("")
    fetchedTransactions.removeAll()
    continuationKey = nil
  }

  func fetchTransactions(accountId: String, dateRange: DateRange, continuationKey: String?) {
    log.verbose("")
    self.accountId = accountId
    self.dateRange = dateRange
    let restRequest = RESTRoutes.transactions(account: accountId,
                                              startDate: dateRange.startDate,
                                              endDate: dateRange.endDate,
                                              contKey: continuationKey)
    sessionManager.request(restRequest).validate().responseJSON { (restResponse) in
      if restResponse.result.isSuccess {
        if let jsonData = restResponse.data, let (txns, contkey) = (sessionManager.adapter as? ESObjectFactory)?.transactionObject().buildFromData(jsonData) {
          self.fetchedTransactions.append(contentsOf: txns)
          self.continuationKey = contkey
          DispatchQueue.main.async {
            self.notifyDelegate()
          }
        }
      } else {
        DispatchQueue.main.async {
          let error = ESError.requestFailure(reason: restResponse.error?.localizedDescription ?? restResponse.result.description)
          self.delegate?.transactionsFetchFailed(worker: self,
                                                 error: error)
        }
      }
    }
  }

  func notifyDelegate() {
    log.verbose("")
    let keepgoing = delegate?.transactionsReceived(worker: self, fetchComplete: continuationKey == nil) ?? false
    if keepgoing {
      fetchTransactions(accountId: accountId, dateRange: dateRange, continuationKey: continuationKey)
    }
  }
}
